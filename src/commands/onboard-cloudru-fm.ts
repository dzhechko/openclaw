import fs from "node:fs/promises";
import path from "node:path";
import type { AuthChoice } from "./onboard-types.js";

/**
 * Cloud.ru FM model preset mapping BIG/MIDDLE/SMALL tiers to concrete model IDs.
 */
export type CloudruModelPreset = {
  /** Full cloud.ru model ID for BIG_MODEL (mapped to claude-cli/opus). */
  big: string;
  /** Full cloud.ru model ID for MIDDLE_MODEL (mapped to claude-cli/sonnet). */
  middle: string;
  /** Full cloud.ru model ID for SMALL_MODEL (mapped to claude-cli/haiku). */
  small: string;
  /** Human-readable label for the preset. */
  label: string;
  /** Whether the default model is free tier. */
  free: boolean;
};

const CLOUDRU_PRESETS: Record<string, CloudruModelPreset> = {
  "cloudru-fm-glm47": {
    big: "zai-org/GLM-4.7",
    middle: "zai-org/GLM-4.7-FlashX",
    small: "zai-org/GLM-4.7-Flash",
    label: "GLM-4.7 (recommended)",
    free: false,
  },
  "cloudru-fm-flash": {
    big: "zai-org/GLM-4.7-Flash",
    middle: "zai-org/GLM-4.7-Flash",
    small: "zai-org/GLM-4.7-Flash",
    label: "GLM-4.7 Flash (free tier)",
    free: true,
  },
  "cloudru-fm-qwen": {
    big: "Qwen/Qwen3-Coder-480B-A35B-Instruct",
    middle: "zai-org/GLM-4.7-FlashX",
    small: "zai-org/GLM-4.7-Flash",
    label: "Qwen3-Coder (coding-optimized)",
    free: false,
  },
};

/**
 * Resolves an AuthChoice to the corresponding Cloud.ru FM model preset.
 *
 * @param choice - An AuthChoice value starting with `"cloudru-fm-"`.
 * @returns The resolved {@link CloudruModelPreset}.
 * @throws If the choice does not map to a known preset.
 */
export function resolveCloudruModelPreset(choice: AuthChoice): CloudruModelPreset {
  const preset = CLOUDRU_PRESETS[choice];
  if (!preset) {
    throw new Error(`Unknown cloud.ru FM preset: ${choice}`);
  }
  return preset;
}

/**
 * Generates a Docker Compose YAML template for the cloud.ru FM proxy.
 *
 * The template uses environment variable references (`${VAR}`) so Docker Compose
 * can resolve them from the `.env` file at runtime.
 */
export function generateDockerComposeTemplate(params: {
  port: number;
  preset: CloudruModelPreset;
}): string {
  const { port, preset } = params;
  return `# Cloud.ru FM Proxy — generated by OpenClaw wizard
# Usage: docker compose -f docker-compose.cloudru-proxy.yml up -d
version: "3.8"

services:
  cloudru-proxy:
    image: ghcr.io/nicepkg/cloudru-fm-proxy:v1.0.0
    container_name: openclaw-cloudru-proxy
    restart: unless-stopped
    ports:
      - "127.0.0.1:${port}:8080"
    environment:
      CLOUDRU_API_KEY: "\${CLOUDRU_API_KEY}"
      BIG_MODEL: "${preset.big}"
      MIDDLE_MODEL: "${preset.middle}"
      SMALL_MODEL: "${preset.small}"
      DISABLE_THINKING: "true"
      HOST: "0.0.0.0"
      PORT: "8080"
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    read_only: true
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: "1.0"
`;
}

/**
 * Writes (or overwrites) a `.env` file in the workspace with the Cloud.ru API key.
 * The file is also added to `.gitignore` via {@link ensureGitignoreEntries}.
 */
export async function writeCloudruEnvFile(params: {
  apiKey: string;
  workspaceDir: string;
}): Promise<void> {
  const envPath = path.join(params.workspaceDir, ".env");
  let existing = "";
  try {
    existing = await fs.readFile(envPath, "utf-8");
  } catch {
    // File does not exist yet — start fresh.
  }

  const lines = existing.split("\n");
  const keyLine = `CLOUDRU_API_KEY=${params.apiKey}`;
  const idx = lines.findIndex((l) => l.startsWith("CLOUDRU_API_KEY="));
  if (idx >= 0) {
    lines[idx] = keyLine;
  } else {
    lines.push(keyLine);
  }

  const content = lines.join("\n").replace(/\n{3,}/g, "\n\n").trim() + "\n";
  await fs.writeFile(envPath, content, "utf-8");

  await ensureGitignoreEntries({
    workspaceDir: params.workspaceDir,
    entries: [".env", "docker-compose.cloudru-proxy.yml"],
  });
}

/**
 * Idempotently adds entries to the workspace `.gitignore`.
 * Entries that already appear (exact line match) are skipped.
 */
export async function ensureGitignoreEntries(params: {
  workspaceDir: string;
  entries: string[];
}): Promise<void> {
  const gitignorePath = path.join(params.workspaceDir, ".gitignore");
  let existing = "";
  try {
    existing = await fs.readFile(gitignorePath, "utf-8");
  } catch {
    // File does not exist yet.
  }

  const existingLines = new Set(existing.split("\n").map((l) => l.trim()));
  const toAdd = params.entries.filter((entry) => !existingLines.has(entry));
  if (toAdd.length === 0) {
    return;
  }

  const suffix = existing.endsWith("\n") || existing === "" ? "" : "\n";
  const appended = existing + suffix + toAdd.join("\n") + "\n";
  await fs.writeFile(gitignorePath, appended, "utf-8");
}
